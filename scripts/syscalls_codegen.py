#!/usr/bin/env python3
"""
Parses solana syscalls and creates java code that will assign the corresponding
function signatures in the eBPFSolanaAnalyzer
"""
import re
FUNCTION_RE = re.compile(r'(?P<return_type>[\w_\*\[\]\d]*)\s+?(?P<name>[\*\w\d_]*)\((?P<args>(.*))\)')

class FunctionEntry:

    def __init__(self, code: str, description: str, line_num: int):
        self.raw_code: str = code
        self.description = description
        self.line_num = line_num

        self.name: str = ''
        self.return_type: str = ''
        self.args: list[tuple(str, str)] = []

    def parse(self):
        m = FUNCTION_RE.search(self.raw_code)
        if not m:
            raise Exception(f"Could not parse code at line {self.line_num}: {self.raw_code}")

        self.return_type = m.group('return_type')
        self.name = m.group('name')

        # in case the format "char *data" was used, move any asterisks to the type
        while self.name.startswith('*'):
            self.return_type += '*'
            self.name = self.name[1:]

        args_str = m.group('args')
        # no args
        if not args_str:
            return

        # parse the arguments
        # expects that there is a single whitespace between the type and the name
        for arg in args_str.split(','):
            try:
                arg_type, arg_name = arg.strip().split(' ')
            except ValueError:
                raise Exception(f"Unexpected whitespace in arguments string {arg}")

            # in case the format "char *data" was used, move any asterisks to the type
            while arg_name.startswith('*'):
                arg_type += '*'
                arg_name = arg_name[1:]
            self.args.append((arg_type, arg_name))

    def generate_java_code(self) -> str:
        s = f'''
                    case("{self.name}"):
                        try {{
                            f = parser.parse(null, "{self.raw_code}");
                        }} catch (CancelledException e) {{
                            return false;
                        }} catch (ParseException e) {{
                            log.appendMsg("Failed parsing solana syscall signature. See exception");
                            log.appendException(e);
                            break;
                        }}

                        cmd = new ApplyFunctionSignatureCmd(s.getAddress(), f, SourceType.ANALYSIS);
                        cmd.applyTo(program, monitor);
                        func.setComment("""
{self.description}
                        """);
                        break;
        '''
        return s

    def __str__(self) -> str:
        s = f"""
description: {self.description}
return_type: {self.return_type}
name:        {self.name}
args:        {self.args}
        """
        return s.strip()


def main():
    with open('solana_syscalls.txt', 'r') as f:
        data = f.read()

    functions: list[FunctionEntry] = []

    comment_lines = []
    for line_num, line in enumerate(data.splitlines()):
        line = line.strip()
        if not line:
            continue

        # skip comments
        if line.startswith("#"):
            continue

        # we have a description
        if line.startswith("///"):
            comment_lines.append(line[3:].strip())
            continue

        # not empty, no description, must be a function declaration
        func = FunctionEntry(line, '\n'.join(comment_lines), line_num)
        comment_lines = []
        functions.append(func)

    for func in functions:
        try:
            func.parse()
        except KeyboardInterrupt:
            raise
        # print(func)

    java_code = []
    for func in functions:
        try:
            code = func.generate_java_code()
            java_code.append(code)
        except KeyboardInterrupt:
            raise

    print("// vvv CODE IS AUTOGENERATED BY syscalls_codegen.py")
    print('\n'.join(java_code))
    print("// ^^^ CODE IS AUTOGENERATED BY syscalls_codegen.py")


if __name__ == '__main__':
    main()
